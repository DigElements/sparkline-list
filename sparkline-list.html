
<!--
Copyright 2017 Next Century Corporation
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../d3-import/d3.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../sparkline-chart/sparkline-chart.html">

<!--
A Polymer Element that displays a list of spark line charts.

### Example
```js
demo.data = [{
  name: 'Chart 1',
  points: [{
    date: new Date(2017, 01, 02),
    count: 0
  }, {
    date: new Date(2017, 01, 09),
    count: 3
  }, {
    date: new Date(2017, 01, 16),
    count: 5
  }, {
    date: new Date(2017, 01, 23),
    count: 3
  }, {
    date: new Date(2017, 01, 30),
    count: 9
  }, {
    date: new Date(2017, 02, 06),
    count: 1
  }, {
    date: new Date(2017, 02, 13),
    count: 9
  }, {
    date: new Date(2017, 02, 20),
    count: 7
  }, {
    date: new Date(2017, 02, 27),
    count: 1
  }]
}, {
  name: 'Chart 2',
  points: [{
    date: new Date(2017, 01, 02),
    count: 0
  }, {
    date: new Date(2017, 01, 09),
    count: 6
  }, {
    date: new Date(2017, 01, 16),
    count: 2
  }, {
    date: new Date(2017, 01, 23),
    count: 1
  }, {
    date: new Date(2017, 01, 30),
    count: 5
  }, {
    date: new Date(2017, 02, 06),
    count: 7
  }, {
    date: new Date(2017, 02, 13),
    count: 2
  }, {
    date: new Date(2017, 02, 20),
    count: 8
  }, {
    date: new Date(2017, 02, 27),
    count: 3
  }]
}, {
  name: 'Chart 3',
  points: [{
    date: new Date(2017, 01, 02),
    count: 1
  }, {
    date: new Date(2017, 01, 09),
    count: 4
  }, {
    date: new Date(2017, 01, 16),
    count: 7
  }, {
    date: new Date(2017, 01, 23),
    count: 7
  }, {
    date: new Date(2017, 01, 30),
    count: 1
  }, {
    date: new Date(2017, 02, 06),
    count: 7
  }, {
    date: new Date(2017, 02, 13),
    count: 1
  }, {
    date: new Date(2017, 02, 20),
    count: 9
  }, {
    date: new Date(2017, 02, 27),
    count: 2
  }]
}, {
  name: 'Chart 4',
  points: [{
    date: new Date(2017, 02, 13),
    count: 1
  }, {
    date: new Date(2017, 02, 20),
    count: 9
  }, {
    date: new Date(2017, 02, 27),
    count: 2
  }]
}, {
  name: 'Chart 5',
  points: [{
    date: new Date(2017, 02, 13),
    count: 5
  }, {
    date: new Date(2017, 02, 20),
    count: 2
  }, {
    date: new Date(2017, 02, 27),
    count: 2
  }]
}, {
  name: 'Chart 6',
  points: [{
    date: new Date(2017, 02, 13),
    count: 4
  }, {
    date: new Date(2017, 02, 20),
    count: 6
  }, {
    date: new Date(2017, 02, 27),
    count: 2
  }]
}, {
  name: 'Chart 7',
  points: [{
    date: new Date(2017, 02, 13),
    count: 3
  }, {
    date: new Date(2017, 02, 20),
    count: 1
}, {
    date: new Date(2017, 02, 27),
    count: 9
  }]
}, {
  name: 'Chart 8',
  points: [{
    date: new Date(2017, 01, 30),
    count: 20
  }]
}];
```

```html
<sparkline-list data="[[data]]"></sparkline-list>
```

### Styling

`<sparkline-list>` provides the following custom properties and mixins for styling:

Custom property               | Description                            | Default
------------------------------|----------------------------------------|--------
`--sparkline-list-max-height` | The max height for the sparkline list. | 300px

@demo demo/index.html
-->

<dom-module id="sparkline-list">
  <template>
    <style include="iron-flex iron-flex-alignment"></style>

    <style>
      :host {
        display: block;
        max-height: var(--sparkline-list-max-height, 300px);
        overflow: auto;
      }

      .sparkline-wrapper {
        height: 20px;
        margin-bottom: 5px;
      }

      iron-icon {
        --iron-icon-height: 20px;
        --iron-icon-width: 20px;
        margin-right: 5px;
        min-width: 20px;
      }

      .name {
        color: var(--primary-text-color);
        font-size: 14px;
        font-weight: 500;
        min-width: 150px;
        max-width: 150px;
        margin-right: 5px;

        display: -webkit-box;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: normal;
        word-break: break-word;
        -webkit-line-clamp: 1;
        -webkit-box-orient: vertical;
      }

      a:hover {
        color: var(--secondary-text-color);
      }

      sparkline-chart {
        margin-right: 5px;
      }

      iron-icon.amber {
        color: var(--paper-amber-600);
      }

      iron-icon.black {
        color: #111;
      }

      iron-icon.blue {
        color: var(--paper-blue-600);
      }

      iron-icon.blue-grey {
        color: var(--paper-blue-grey-600);
      }

      iron-icon.brown {
        color: var(--paper-brown-600);
      }

      iron-icon.cyan {
        color: var(--paper-cyan-600);
      }

      iron-icon.deep-orange {
        color: var(--paper-deep-orange-600);
      }

      iron-icon.deep-purple {
        color: var(--paper-deep-purple-600);
      }

      iron-icon.green {
        color: var(--paper-green-600);
      }

      iron-icon.grey {
        color: var(--paper-grey-600);
      }

      iron-icon.indigo {
        color: var(--paper-indigo-600);
      }

      iron-icon.light-blue {
        color: var(--paper-light-blue-600);
      }

      iron-icon.light-green {
        color: var(--paper-light-green-600);
      }

      iron-icon.lime {
        color: var(--paper-lime-600);
      }

      iron-icon.orange {
        color: var(--paper-orange-600);
      }

      iron-icon.pink {
        color: var(--paper-pink-600);
      }

      iron-icon.purple {
        color: var(--paper-purple-600);
      }

      iron-icon.red {
        color: var(--paper-red-600);
      }

      iron-icon.teal {
        color: var(--paper-teal-600);
      }

      iron-icon.white {
        color: #fff;
      }

      iron-icon.yellow {
        color: var(--paper-yellow-600);
      }
    </style>

    <template is="dom-repeat" items="[[_histograms]]" initial-count="10">
      <div class="layout horizontal center sparkline-wrapper">
        <template is="dom-if" if="[[!hideName]]">
          <template is="dom-if" if="[[_getProperty(item, iconProperty)]]">
            <iron-icon class$="[[_getProperty(item, styleClassProperty)]]" icon="[[_getProperty(item, iconProperty)]]"></iron-icon>
          </template>

          <template is="dom-if" if="[[_getProperty(item, linkProperty)]]">
            <a class="name" href$="[[_getProperty(item, linkProperty)]]" title$="Open [[_getProperty(item, nameProperty)]]">[[_getProperty(item, nameProperty)]]</a>
          </template>

          <template is="dom-if" if="[[!_getProperty(item, linkProperty)]]">
            <div class="name" title$="[[_getProperty(item, nameProperty)]]">[[_getProperty(item, nameProperty)]]</div>
          </template>
        </template>

        <sparkline-chart class="layout horizontal flex"
          points="[[_getProperty(item, pointsProperty)]]"
          x-prop="[[xProperty]]"
          y-prop="[[yProperty]]"
          style-class="[[_getProperty(item, styleClassProperty)]]">
        </sparkline-chart>
      </div>
    </template>
  </template>

  <script>
    Polymer({
      is: 'sparkline-list',

      properties: {
        /**
         * (Required)
         *
         * The list of objects containing points for the sparklines.
         *
         * @type {Array}
         */
        data: {
          type: Array
        },

        /**
         * (Optional)
         *
         * Whether to hide the names and icons.
         *
         * @type {Boolean}
         * @default false
         */
        hideName: {
          type: Boolean,
          value: false
        },

        /**
         * (Optional)
         *
         * The property for the icon for the objects in the data (if any).
         *
         * @type {String}
         * @default 'icon'
         */
        iconProperty: {
          type: String,
          value: 'icon'
        },

        /**
         * (Optional)
         *
         * The property for the link for the objects in the data (if any).
         *
         * @type {String}
         * @default 'icon'
         */
        linkProperty: {
          type: String,
          value: 'link'
        },

        /**
         * (Optional)
         *
         * The property for the name for the objects in the data.
         *
         * @type {String}
         * @default 'name'
         */
        nameProperty: {
          type: String,
          value: 'name'
        },

        /**
         * (Optional)
         *
         * The property for the points for the objects in the data.
         *
         * @type {String}
         * @default 'points'
         */
        pointsProperty: {
          type: String,
          value: 'points'
        },

        /**
         * (Optional)
         *
         * The property for the style class for the objects in the data (if any).
         *
         * @type {String}
         * @default ''
         */
        styleClassProperty: {
          type: String,
          value: 'styleClass'
        },

        /**
         * (Optional)
         *
         * The time interval of the sparklines.  Options:  'day', 'week'
         *
         * @type {String}
         * @default 'week'
         */
        timeInterval: {
          type: String,
          value: 'week'
        },

        /**
         * The property that will hold the x value (domain) for each point.  Must have date objects or strings.
         *
         * @type {String}
         * @default 'date'
         */
        xProperty: {
          type: String,
          value: 'date'
        },

        /**
         * The property that will hold the y value (range) for each point.  Must have numbers.
         *
         * @type {String}
         * @default 'count'
         */
        yProperty: {
          type: String,
          value: 'count'
        },

        /**
         * The list of objects containing scaled and padded points for the sparklines.
         *
         * @type {Array}
         * @private
         */
        _histograms: {
          computed: '_buildHistograms(data, timeInterval)',
          type: Array
        }
      },

      /**
       * Builds the histograms for the sparklines from the given data.
       *
       * @param {Array} data
       * @param {String} timeInterval
       * @return {Array}
       * @private
       */
      _buildHistograms: function(data, timeInterval) {
        if(!data || !data.length) {
          return data;
        }

        var self = this;
        return this._padHistograms(this._scaleHistograms(data.map(function(item) {
          item[self.pointsProperty] = item[self.pointsProperty].map(function(oldPoint) {
            var newPoint = {};
            newPoint[self.xProperty] = typeof oldPoint[self.xProperty] === 'string' ? new Date(oldPoint[self.xProperty]) : oldPoint[self.xProperty];
            newPoint[self.yProperty] = oldPoint[self.yProperty];
            return newPoint;
          });
          return item;
        })), timeInterval);
      },

      /**
       * Returns the object in the given item at the given property.
       *
       * @param {Object} item
       * @param {String} property
       * @return {Object}
       * @private
       */
      _getProperty: function(item, property) {
        return item ? item[property] : undefined;
      },

      /**
       * Pads the given histogram data so that each point has zero-count values to its left and right if needed.
       *
       * @param {Array} data
       * @param {String} timeInterval
       * @return {Array}
       * @private
       */
      _padHistograms: function(data, timeInterval) {
        var xscale = d3.time.scale().domain([new Date(2000, 1, 1), new Date(2000, 1, 2)]).range([0, 1]);
        var xunscale = d3.time.scale().domain([0, 1]).range([new Date(2000, 1, 1), new Date(2000, 1, 2)]);

        if(timeInterval === 'week') {
          xscale = d3.time.scale().domain([new Date(2000, 1, 1), new Date(2000, 1, 8)]).range([0, 1]);
          xunscale = d3.time.scale().domain([0, 1]).range([new Date(2000, 1, 1), new Date(2000, 1, 8)]);
        }

        var self = this;
        return data.map(function(item) {
          var points = [item[self.pointsProperty][0]];

          for(var i = 1; i < item[self.pointsProperty].length; ++i) {
            var previous = item[self.pointsProperty][i - 1];
            var next = item[self.pointsProperty][i];

            // Add a zero-count point after the previous point if the previous point is more than one tick away and non-zero.
            if(previous[self.yProperty] && xscale(next[self.xProperty]) - xscale(previous[self.xProperty]) > 1) {
              var point = {};
              point[self.xProperty] = new Date(xunscale(xscale(previous[self.xProperty]) + 1));
              point[self.yProperty] = 0;
              points.push(point);
            }

            // Add a zero-count point before the next point if the next point is more than one tick away and non-zero.
            if(next[self.yProperty] && xscale(next[self.xProperty]) - xscale(previous[self.xProperty]) > 2) {
              var point = {};
              point[self.xProperty] = new Date(xunscale(xscale(next[self.xProperty]) - 1));
              point[self.yProperty] = 0;
              points.push(point);
            }

            // Add the next point.
            points.push(next);
          }

          var paddedHistogram = {};
          paddedHistogram[self.iconProperty] = item[self.iconProperty];
          paddedHistogram[self.linkProperty] = item[self.linkProperty];
          paddedHistogram[self.nameProperty] = item[self.nameProperty];
          paddedHistogram[self.styleClassProperty] = item[self.styleClassProperty];
          paddedHistogram[self.pointsProperty] = points;
          return paddedHistogram;
        });
      },

      /**
       * Scales the given histogram data so that each histogram has the same x-axis range.
       *
       * @param {Array} data
       * @return {Array}
       * @private
       */
      _scaleHistograms: function(data) {
        var self = this;
        var scaledRange;
        var ranges = data.map(function(item) {
          var range = d3.extent(item[self.pointsProperty], function(point) {
            return point[self.xProperty];
          });

          if(!scaledRange && range[0] && range[1]) {
            scaledRange = [range[0], range[1]];
          }

          if(range[0] && range[0].getTime() < scaledRange[0].getTime()) {
            scaledRange[0] = range[0];
          }

          if(range[1] && range[1].getTime() > scaledRange[1].getTime()) {
            scaledRange[1] = range[1];
          }

          return range;
        });

        return ranges.map(function(range, index) {
          var scaledHistogram = {};
          scaledHistogram[self.iconProperty] = data[index][self.iconProperty];
          scaledHistogram[self.linkProperty] = data[index][self.linkProperty];
          scaledHistogram[self.nameProperty] = data[index][self.nameProperty];
          scaledHistogram[self.styleClassProperty] = data[index][self.styleClassProperty];
          scaledHistogram[self.pointsProperty] = [];

          if(range[0].getTime() !== scaledRange[0].getTime()) {
            var point = {};
            point[self.xProperty] = new Date(scaledRange[0]);
            point[self.yProperty] = 0;
            scaledHistogram[self.pointsProperty].push(point);
          }

          scaledHistogram[self.pointsProperty] = scaledHistogram[self.pointsProperty].concat(data[index][self.pointsProperty]);

          if(range[1].getTime() !== scaledRange[1].getTime()) {
            var point = {};
            point[self.xProperty] = new Date(scaledRange[1]);
            point[self.yProperty] = 0;
            scaledHistogram[self.pointsProperty].push(point);
          }

          return scaledHistogram;
        });
      }
    });
  </script>
</dom-module>
